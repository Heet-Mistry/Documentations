*** Objects ***
Objects are the data storage for storing the key:value pair in the data.

let obj = new Object(); // object construtor syntax 
let obj = {}; // object litral syntax

obj = {
  name:"dire",
  surname:"localhost"
}

obj.name 
obj.surname

for deleting the property we can make use of the delete operator 
delete obj.name;

we can also use the multiline property names as the key but they should be quoted 
like "some multiline key"

let obj = {
  "full name":"something"
}

for accessing this type of the keys we have to make use of the square bracket 
obj["full name"]

If the key does not exist in the object it will give the undefined if we access it.
also we can give the property name as the variable name for doing that we 
have to make use of the square bracket, this is called the COMPUTED PROPERTIES.

let a = "name";
let obj = {
  [a]:"some name"
}

when we have the key and the value as the same then we can put it in the 
shorthand notation such as 

let obj = {
  name,
  surname
}

NOTE = In the objects if we give some key as the litral other then the string 
then the given value will be converted to the string by default automatically.

For checking if some key exist in the object we can make use of the in operator 
> "key" in obj => true/false ===> it is recommended to check it with this for 
checking if the key exists inside the ibject or not.

for iterating in the object we can iterate them like 
for(let key in obj){
  log(obj[key]);
}
here it is same for the arrays because arrays are also one sort of objects.

we can also iterate in the object by doing like 
for(let [k,v] of Object.entries(obj)){
  
}

NOTE = Very Important to note that the objects and arrays are stored as the 
reference where the strings and other primitive types are not. so if we create 
some object and then we assign it to some other and then if we change something 
in the second one then it will also be reflected into the first one.

when we assign some object to the variable then that variable will not be storing 
the object but it will have the value of the address where the object is lying.

let a = {}
let b = {}
a==b ==> false because the reference is different




*** This pointer in the objects ***
The value of the this is the object before the dot. The value of the this pointer 
is evaluated at the runtime depending on the context. Rathet then the other 
programming languages the this pointer in the javascript is not bound, it does
not depend on the method where it is created but it is dependent on the method 
where it is called inside the code.s

Also the arrow function in the javascript have no this. Do not use the arrow 
function in the object methods where we are using the this pointer.

we can create the objects using the object literal syntax and also we can 
make the object with the function constructor syntax.

function User(name){
  // this = {} // this is the thing that js do actually
  this.name = name;
  this.surname = "some surname";
  // return this; // same thing js do
}

let obj = new User("dhairya")

when we execute the function in the new what happens is it will create the 
new emty object and then it will assign it to this and then when the function 
body executes then it will then modifies the this.

NOTE = Technically any functions can be used as the constructor except the 
arrow function as they do not have the this pointers.
 
Optional chaining ===> ?.
when we do it like obj?.prop?.otherProp ==> it will check each and every 
property in the chain and it will stop when one is undefined or null and 
it will return the undefined, it will not throw any error.


for clonning the objects we can use the method assign 
let obj = {
  user:"name",
  surname:"rupala"
}

let clone = Object.assign({},obj, and other objects )
here the first arg is the destination object where we want all the 
property of the other objects should go in. 

for the nested clonning we have to make use of the structuredClone() method 
the assign will not work, as it will work only for the single level copies. 
let clone = structuredClone(user), but it is not recommended to use it 
when the object has the function properties, the method faisl so we have to make 
our own code snippet. 


Objects and the this pointer...
In objects we can also directly write the funtion methods without writing the 
function keyword such as 

let user = {
  sayHi(){
    something computation..
  }
}

this can be used to access the property of the same object.

let user = {
  name:"some name",
  sayHi(){
    this.name
  }
}

here the this is computed dynamically, it is
evaluated at run time depending on the context of the  
program it is not always the object it self
when we do the function call such as

user.sayHi() the this will take the objeect before the dot operator. 


let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

// use the same function in two objects
user.f = sayHi;
admin.f = sayHi;

// these calls have different this
// "this" inside the function is the object "before the dot"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)


consider the below example 
function sayHi() {
  alert(this);
}
sayHi(); // undefined


here the this is undefined because of the strict mode and, and if the strict mode 
is not on then the this will be the global window object. So if we 
are using this inside a function then it should be called inside the object 
context. 

the arrow functions do not have this, if we use this inside the arrow function 
then it will take the this as the outer function this. 

let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};
user.sayHi(); // Ilya

if directly use it then the thsi will be the empty object 
let user= {
  name:"dhairya",
  sayHi:()=>{
    log(this) // it will give {}
  }
}


often we need to create many similar type of functions so we need to use 
the function constructor syntax for that, the constructor functions are the 
functions which are the name is capital and they should be executed with the 
new operator. 


generally the global object in the browser environment is defined as the 
window and the global object in the node.js is defined as the global. when we 
declare the var then it will automatically be the part of the global object. same 
goes for the function declaration. 


Evrything in the javascript is a value, and the function is also a value and its 
type is object. 
functions have some properties inbuilt such as name and length.

the func.name gives the name of the function 
func.length gives the nmber of arguments. in the length the rest parameters 
are not counted. 


Object getters and setter>>>
There are two types of properties in objects, one is data property and the 
second is the accessor property. They are essentially the functions that executes 
on getting or setting the value. 

let obj = {
  get propName() {
    // getter, the code executed on getting obj.propName
  },

  set propName(value) {
    // setter, the code executed on setting obj.propName = value
  }
};



let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};

// set fullName is executed with the given value.
user.fullName = "Alice Cooper";

alert(user.name); // Alice
alert(user.surname); // Cooper